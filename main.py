import json
import os
import datetime
import joblib

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
from difflib import SequenceMatcher as ComparadorSequencia

# --- Configura√ß√µes Principais do Chatbot ---
ARQUIVO_BASE_CONHECIMENTO = 'base_conhecimento.json'
ARQUIVO_MODELO_ML = 'modelo_chatbot.joblib'
DIRETORIO_HISTORICO_USUARIOS = 'historico_usuarios'

# --- Fun√ß√µes para Gerenciar a Base de Conhecimento ---
def carregar_base_conhecimento():
    """
    Carrega as frases de treinamento e suas categorias de um arquivo JSON.
    Se o arquivo n√£o existir, inicia com uma base padr√£o para a cl√≠nica.
    """
    if os.path.exists(ARQUIVO_BASE_CONHECIMENTO):
        with open(ARQUIVO_BASE_CONHECIMENTO, 'r', encoding='utf-8') as arquivo:
            dados = json.load(arquivo)
            return dados['frases'], dados['categorias']
    else:
        # Base de Conhecimento Inicial da Cl√≠nica - CORRIGIDA (mesmo n√∫mero de frases e categorias)
        frases_iniciais = [
            # Sauda√ß√µes (11 frases)
            "bom dia", "boa tarde", "boa noite", "oi", "ol√°", "tudo bem?", "e a√≠", "sauda√ß√µes", "ol√°, tudo bem?",
            "como voc√™ est√°", "hey",
            
            # Ajuda (10 frases)
            "preciso de ajuda", "preciso de aux√≠lio", "gostaria de ajuda", "me ajude", "socorro", "pode me ajudar?", 
            "tenho uma d√∫vida", "n√£o sei como fazer", "preciso de orienta√ß√£o", "como funciona",
            
            # Informa√ß√µes sobre a cl√≠nica (13 frases)
            "qual hor√°rio de funcionamento", "que horas voc√™s abrem", "telefone da cl√≠nica", "endere√ßo da cl√≠nica", 
            "contato", "localiza√ß√£o", "qual o hor√°rio", "quais os telefones", "onde fica a cl√≠nica", 
            "hor√°rio de atendimento", "como chegar", "qual o endere√ßo", "n√∫mero de telefone",
            
            # Cancelamento (8 frases)
            "quero cancelar meu plano", "cancelamento", "n√£o quero mais continuar com plano", "cancelar", 
            "desativar conta", "gostaria de cancelar", "encerrar plano", "cancelar assinatura",
            
            # Exames (13 frases)
            "exame", "quero saber valores dos meus exames", "resultado exames", "exames", "agendar exame", 
            "laborat√≥rio", "verificar exame", "como pego resultado", "consulta de exames", "quais exames voc√™s fazem",
            "marcar exame", "resultados de exames", "laudo m√©dico",
            
            # Or√ßamentos e Valores (16 frases)
            "or√ßamento", "valores", "qual valor", "me fa√ßa or√ßamento", "quais planos", "me diga valores", 
            "valor", "pre√ßos", "qual pre√ßo", "quanto custa", "pre√ßo da consulta", "valor do exame",
            "or√ßamentos", "tabela de pre√ßos", "custos", "quanto √©"
        ]
        
        categorias_iniciais = [
            # Sauda√ß√µes 
            "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO", "SAUDA√á√ÉO",
            "SAUDA√á√ÉO", "SAUDA√á√ÉO",
            
            # Ajuda 
            "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA", "AJUDA",
            
            # Informa√ß√µes 
            "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", 
            "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO", "INFORMA√á√ÉO",
            
            # Cancelamento 
            "CANCELAMENTO", "CANCELAMENTO", "CANCELAMENTO", "CANCELAMENTO", "CANCELAMENTO", "CANCELAMENTO", 
            "CANCELAMENTO", "CANCELAMENTO",
            
            # Exames 
            "EXAMES", "EXAMES", "EXAMES", "EXAMES", "EXAMES", "EXAMES", "EXAMES", "EXAMES", "EXAMES", 
            "EXAMES", "EXAMES", "EXAMES", "EXAMES",
            
            # Valores/Or√ßamentos 
            "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES",
            "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES", "VALORES"
        ]
        
        # VERIFICA√á√ÉO DE CONSIST√äNCIA
        if len(frases_iniciais) != len(categorias_iniciais):
            print(f"‚ö†Ô∏è  AVISO: Inconsist√™ncia detectada! Frases: {len(frases_iniciais)}, Categorias: {len(categorias_iniciais)}")
            # Ajusta automaticamente para ter o mesmo n√∫mero
            min_length = min(len(frases_iniciais), len(categorias_iniciais))
            frases_iniciais = frases_iniciais[:min_length]
            categorias_iniciais = categorias_iniciais[:min_length]
            print(f"‚úÖ Ajustado para: Frases: {len(frases_iniciais)}, Categorias: {len(categorias_iniciais)}")
        
        return frases_iniciais, categorias_iniciais

def salvar_base_conhecimento(frases: list, categorias: list):
    """Salva as frases e categorias atualizadas no arquivo JSON da base de conhecimento."""
    # Verifica consist√™ncia antes de salvar
    if len(frases) != len(categorias):
        print(f"‚ùå ERRO: N√£o √© poss√≠vel salvar - Frases ({len(frases)}) e Categorias ({len(categorias)}) t√™m quantidades diferentes!")
        return
    
    dados = {'frases': frases, 'categorias': categorias}
    with open(ARQUIVO_BASE_CONHECIMENTO, 'w', encoding='utf-8') as arquivo:
        json.dump(dados, arquivo, indent=4, ensure_ascii=False)

# Fun√ß√£o para verificar e corrigir consist√™ncia dos dados
def verificar_consistencia_dados(frases: list, categorias: list) -> tuple:
    """Verifica e corrige inconsist√™ncias entre frases e categorias."""
    if len(frases) != len(categorias):
        print(f"‚ö†Ô∏è  Corrigindo inconsist√™ncia: Frases ({len(frases)}) vs Categorias ({len(categorias)})")
        # Mant√©m apenas os pares que t√™m ambos
        min_length = min(len(frases), len(categorias))
        frases = frases[:min_length]
        categorias = categorias[:min_length]
        print(f"‚úÖ Dados ajustados: {len(frases)} pares consistentes")
    return frases, categorias

# Carrega a base de conhecimento no in√≠cio do programa
FRASES_CONHECIDAS, CATEGORIAS_CONHECIDAS = carregar_base_conhecimento()

# Verifica consist√™ncia imediatamente ap√≥s carregar
FRASES_CONHECIDAS, CATEGORIAS_CONHECIDAS = verificar_consistencia_dados(FRASES_CONHECIDAS, CATEGORIAS_CONHECIDAS)

# Respostas pr√©-definidas para cada categoria identificada pelo chatbot
RESPOSTAS_PRE_DEFINIDAS = {
    "SAUDA√á√ÉO": {
        "initial": "Ol√°! Seja bem-vindo √† nossa cl√≠nica. Como posso ajudar voc√™ hoje?"
    },
    "AJUDA": {
        "initial": "Claro! Posso ajudar com  agendamentos, ou d√∫vidas gerais. O que voc√™ precisa?",
        "continuation": "Em que mais posso ajudar agora?"
    },
    "INFORMA√á√ÉO": {
        "initial": (
            "üìã **Informa√ß√µes da Cl√≠nica:**\n"
            "‚Ä¢ **Hor√°rio de Atendimento:** Segunda a Sexta, das 7h √†s 19h\n"
            "‚Ä¢ **Telefone:** (11) 3333-4444\n"
            "‚Ä¢ **Endere√ßo:** Rua Sa√∫de Perfeita, 123 - Centro\n"
            "‚Ä¢ **WhatsApp:** (11) 98888-7777"
        ),
        "continuation": "Precisa de mais alguma informa√ß√£o sobre a cl√≠nica?"
    },
    "CANCELAMENTO": {
        "initial": (
            "Poxa, que pena! Para prosseguir com o cancelamento do seu plano, "
            "preciso transferir voc√™ para um de nossos atendentes. "
            "Aguarde um instante, por favor."
        ),
        "continuation": (
            "Entendi sobre o cancelamento. Vou te transferir para um atendente agora. "
            "Tenha um √≥timo dia!"
        )
    },
    "EXAMES": {
        "initial": "Nossos servi√ßos de exames incluem:\n‚Ä¢ Agendamento de Exames\n‚Ä¢ Consulta de Resultados Online\nQual servi√ßo voc√™ gostaria de usar?",
        "continuation": "Sobre exames, em que mais posso ajudar?"
    },
    "VALORES": {
        "initial": "Para or√ßamentos e valores, √© necess√°rio consultar diretamente na cl√≠nica para obter informa√ß√µes precisas sobre pre√ßos e planos dispon√≠veis.",
        "continuation": "Sobre valores e or√ßamentos, preciso que voc√™ consulte diretamente na cl√≠nica para informa√ß√µes precisas."
    },
    "DESCONHECIDO": {
        "initial": "Desculpe, n√£o consegui entender sua pergunta no momento. Voc√™ poderia reformular de outra forma?"
    }
}

# --- Treinamento e Gerenciamento do Modelo de Machine Learning ---
def criar_e_treinar_pipeline_ml(frases: list, categorias: list) -> Pipeline:
    """
    Cria e treina um pipeline de Machine Learning (vetoriza√ß√£o + classifica√ß√£o)
    usando o Scikit-learn para identificar a categoria das mensagens.
    """
    # Verifica√ß√£o final antes do treinamento
    if len(frases) != len(categorias):
        raise ValueError(f"N√£o √© poss√≠vel treinar o modelo: Frases ({len(frases)}) e Categorias ({len(categorias)}) t√™m quantidades diferentes!")
    
    if len(frases) == 0:
        raise ValueError("N√£o √© poss√≠vel treinar o modelo: N√£o h√° dados de treinamento!")
    
    print(f"üîß Treinando modelo com {len(frases)} exemplos...")
    
    pipeline_ml = Pipeline([
        ('vetorizacao', TfidfVectorizer(lowercase=True)),
        ('classificador', MultinomialNB())
    ])
    pipeline_ml.fit(frases, categorias)
    print("‚úÖ Modelo treinado com sucesso!")
    return pipeline_ml

def carregar_ou_treinar_modelo_ml(frases: list, categorias: list) -> Pipeline:
    """
    Tenta carregar um modelo de ML j√° treinado de um arquivo. Se o arquivo n√£o existe
    ou se houver erro ao carregar, treina um novo modelo e o salva.
    """
    # Verifica consist√™ncia antes de qualquer opera√ß√£o
    frases, categorias = verificar_consistencia_dados(frases, categorias)
    
    if os.path.exists(ARQUIVO_MODELO_ML):
        try:
            modelo = joblib.load(ARQUIVO_MODELO_ML)
            print("‚úÖ Modelo de chatbot de ML carregado com sucesso do arquivo.")
            return modelo
        except Exception as erro:
            print(f"‚ö†Ô∏è Erro ao carregar o modelo '{ARQUIVO_MODELO_ML}': {erro}. Retreinando...")
            modelo = criar_e_treinar_pipeline_ml(frases, categorias)
            joblib.dump(modelo, ARQUIVO_MODELO_ML)
            print("‚úÖ Modelo de chatbot de ML retreinado e salvo novamente.")
            return modelo
    else:
        modelo = criar_e_treinar_pipeline_ml(frases, categorias)
        joblib.dump(modelo, ARQUIVO_MODELO_ML)
        print("‚úÖ Modelo de chatbot de ML treinado e salvo pela primeira vez.")
        return modelo

# Carrega ou treina o modelo de ML uma √∫nica vez quando o sistema inicia
try:
    MODELO_CHATBOT_ML = carregar_ou_treinar_modelo_ml(FRASES_CONHECIDAS, CATEGORIAS_CONHECIDAS)
    print(f"üöÄ Chatbot inicializado com sucesso! Modelo pronto para uso.")
except Exception as e:
    print(f"‚ùå Erro cr√≠tico ao inicializar o modelo: {e}")
    print("üí° Verifique se h√° dados suficientes na base de conhecimento.")
    exit(1)




def obter_texto_resposta(categoria: str, historico_usuario: list) -> str:
    """Define qual vers√£o da resposta deve ser usada para uma dada categoria."""
    if categoria not in RESPOSTAS_PRE_DEFINIDAS:
        return RESPOSTAS_PRE_DEFINIDAS["DESCONHECIDO"]["initial"]

    if not historico_usuario:
        return RESPOSTAS_PRE_DEFINIDAS[categoria]["initial"]

    ultima_categoria_interacao = None
    if historico_usuario and 'categoria' in historico_usuario[-1]:
        ultima_categoria_interacao = historico_usuario[-1]['categoria']

    if "continuation" in RESPOSTAS_PRE_DEFINIDAS[categoria] and \
       ultima_categoria_interacao in ["SAUDA√á√ÉO", "AJUDA"]:
        return RESPOSTAS_PRE_DEFINIDAS[categoria]["continuation"]
    
    return RESPOSTAS_PRE_DEFINIDAS[categoria]["initial"]

def obter_resposta_fallback(
    mensagem: str, frases_conhecidas: list, categorias_conhecidas: list,
    historico_usuario: list, limiar_similaridade: float = 0.5
) -> tuple:
    """Mecanismo de fallback para quando o modelo de ML n√£o est√° confiante."""
    mensagem_lower = mensagem.lower()
    
    palavras_chave_prioritarias = {
        "cancelar": "CANCELAMENTO", "cancelamento": "CANCELAMENTO", "plano": "CANCELAMENTO",
        "exame": "EXAMES", "resultado": "EXAMES", "agendar": "EXAMES", "laborat√≥rio": "EXAMES",
        "hor√°rio": "INFORMA√á√ÉO", "telefone": "INFORMA√á√ÉO", "endere√ßo": "INFORMA√á√ÉO", "contato": "INFORMA√á√ÉO",
        "ajuda": "AJUDA", "aux√≠lio": "AJUDA", "socorro": "AJUDA", "d√∫vida": "AJUDA",
        "oi": "SAUDA√á√ÉO", "ol√°": "SAUDA√á√ÉO", "bom dia": "SAUDA√á√ÉO", "boa tarde": "SAUDA√á√ÉO", "boa noite": "SAUDA√á√ÉO",
        "or√ßamento": "VALORES", "pre√ßo": "VALORES", "valor": "VALORES", "quanto custa": "VALORES", "custa": "VALORES"
    }
    
    for palavra, categoria_prioritaria in palavras_chave_prioritarias.items():
        if palavra in mensagem_lower:
            texto_resposta = obter_texto_resposta(categoria_prioritaria, historico_usuario)
            return texto_resposta, categoria_prioritaria, True

    maior_similaridade = 0
    categoria_mais_similar = None

    for frase_base, categoria_base in zip(frases_conhecidas, categorias_conhecidas):
        similaridade = ComparadorSequencia(None, mensagem_lower, frase_base.lower()).ratio()
        if similaridade > maior_similaridade:
            maior_similaridade = similaridade
            categoria_mais_similar = categoria_base

    if maior_similaridade >= limiar_similaridade and categoria_mais_similar in RESPOSTAS_PRE_DEFINIDAS:
        texto_resposta = obter_texto_resposta(categoria_mais_similar, historico_usuario)
        return texto_resposta, categoria_mais_similar, True
    else:
        return None, None, False

def classificar_e_responder(
    mensagem: str,
    historico_usuario: list,
    modelo_ml: Pipeline,
    frases_conhecidas: list,
    categorias_conhecidas: list,
    limiar_confianca_ml: float = 0.4
) -> tuple:
    """Processa a mensagem do usu√°rio e gera a resposta adequada."""
    mensagem_limpa = mensagem.strip().lower()

    probabilidades = modelo_ml.predict_proba([mensagem_limpa])[0]
    indice_maior_prob = probabilidades.argmax()
    maior_probabilidade = probabilidades[indice_maior_prob]
    categoria_prevista_ml = modelo_ml.classes_[indice_maior_prob]

    if maior_probabilidade >= limiar_confianca_ml and categoria_prevista_ml in RESPOSTAS_PRE_DEFINIDAS:
        texto_resposta = obter_texto_resposta(categoria_prevista_ml, historico_usuario)
        return texto_resposta, categoria_prevista_ml, True

    texto_fallback, categoria_fallback, fallback_usado = obter_resposta_fallback(
        mensagem_limpa, frases_conhecidas, categorias_conhecidas, historico_usuario
    )
    if fallback_usado:
        return texto_fallback, categoria_fallback, True

    return RESPOSTAS_PRE_DEFINIDAS["DESCONHECIDO"]["initial"], "DESCONHECIDO", False

def carregar_historico_usuario(id_usuario: str) -> list:
    """Carrega o hist√≥rico de conversas de um usu√°rio espec√≠fico."""
    caminho_arquivo_usuario = os.path.join(DIRETORIO_HISTORICO_USUARIOS, f"{id_usuario}_historico.json")
    if os.path.exists(caminho_arquivo_usuario):
        with open(caminho_arquivo_usuario, 'r', encoding='utf-8') as arquivo:
            return json.load(arquivo)
    return []

def salvar_historico_usuario(id_usuario: str, mensagem: str, resposta_bot: str, categoria: str):
    """Salva a intera√ß√£o no hist√≥rico do usu√°rio."""
    if not os.path.exists(DIRETORIO_HISTORICO_USUARIOS):
        os.makedirs(DIRETORIO_HISTORICO_USUARIOS)

    historico = carregar_historico_usuario(id_usuario)
    historico.append({
        "mensagem_usuario": mensagem,
        "resposta_chatbot": resposta_bot,
        "categoria": categoria,
        "timestamp": datetime.datetime.now().isoformat()
    })
    
    caminho_arquivo_usuario = os.path.join(DIRETORIO_HISTORICO_USUARIOS, f"{id_usuario}_historico.json")
    with open(caminho_arquivo_usuario, 'w', encoding='utf-8') as arquivo:
        json.dump(historico, arquivo, indent=4, ensure_ascii=False)

def servico_chatbot_entrada(id_usuario: str, mensagem_usuario: str) -> dict:
    """Fun√ß√£o principal para integra√ß√£o com backend."""
    historico_atual_usuario = carregar_historico_usuario(id_usuario)

    texto_resposta, categoria_detectada, usou_base_conhecimento = classificar_e_responder(
        mensagem_usuario, historico_atual_usuario, MODELO_CHATBOT_ML, FRASES_CONHECIDAS, CATEGORIAS_CONHECIDAS
    )

    salvar_historico_usuario(id_usuario, mensagem_usuario, texto_resposta, categoria_detectada)

    return {
        "resposta_chatbot": texto_resposta,
        "categoria": categoria_detectada,
        "usou_base_conhecimento": usou_base_conhecimento
    }

# --- Uso Local ---
if __name__ == "__main__":
    print("--- Chatbot da Cl√≠nica (Modo Console) ---")
    print("Digite 'sair' ou 'tchau' para encerrar a conversa a qualquer momento.")

    id_usuario_teste = input("Por favor, digite seu nome ou um ID para come√ßar: ").strip()
    if not id_usuario_teste:
        id_usuario_teste = "usuario_padrao"
        print(f"Nenhum nome/ID digitado, usando ID padr√£o: {id_usuario_teste}")

    print(f"\nOl√°, {id_usuario_teste}! Iniciando sua conversa com o chatbot da cl√≠nica...")
    print(f"Chatbot: {RESPOSTAS_PRE_DEFINIDAS['SAUDA√á√ÉO']['initial']}")

    while True:
        entrada_usuario = input(f"{id_usuario_teste}> ").strip()
        
        if entrada_usuario.lower() in ['sair', 'exit', 'tchau', 'encerrar','obrigado','adeus']:
            print("Chatbot: Chat encerrado. Tenha um √≥timo dia! üëã")
            break

        resultado_servico = servico_chatbot_entrada(id_usuario_teste, entrada_usuario)

        print(f"Chatbot: {resultado_servico['resposta_chatbot']}")
        print(f"  (Categoria Detectada: {resultado_servico['categoria']}, Resposta da KB: {resultado_servico['usou_base_conhecimento']})")
        print("-" * 50)